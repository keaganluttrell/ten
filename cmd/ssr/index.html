<!DOCTYPE html>
<html>
<head>
    <title>Ten Client</title>
    <style>body { font-family: monospace; }</style>
</head>
<body>
    <h1>Ten 9P Client</h1>
    <div>
        <input type="text" id="username" placeholder="Username (e.g. adm, alice, bob)" value="alice" style="padding: 5px; width: 250px;">
        <button onclick="registerPasskey()">Register Passkey</button>
        <button onclick="loginPasskey()">Login with Passkey</button>
    </div>
    <div id="log"></div>

    <script>
        const log = (msg) => {
            const el = document.getElementById('log');
            el.innerHTML += `<div>${msg}</div>`;
            console.log(msg);
        };

        const ws = new WebSocket('ws://localhost:9009/ws');
        ws.binaryType = 'arraybuffer';

        // simple state machine
        let step = 0; 
        const rootFid = 1;

        ws.onopen = () => {
            log('Connected to Kernel');
            log(`Secure Context: ${window.isSecureContext}`);
            log(`Origin: ${window.location.origin}`);
            log(`Hostname: ${window.location.hostname}`);
            sendTversion();
        };

        ws.onmessage = (event) => {
            const view = new DataView(event.data);
            const size = view.getUint32(0, true);
            const type = view.getUint8(4);
            const tag = view.getUint16(5, true);
            
            log(`Received: Size=${size} Type=${type} Tag=${tag}`);
            
            if (type === 101) { // Rversion
                log('Handshake Successful (Rversion)');
                sendTattach();
            } else if (type === 105) { // Rattach
                log('Attached to / (Rattach)');
                // Now list root!
                // Twalk rootFid(1) -> newFid(2) (Clone)
                // Then Topen newFid(2)
                // Then Tread newFid(2)
                // Just Tread rootFid directly (assuming it's open? Tattach returns open fid? No, Attach returns a fid representing root, but need to open? 
                // Plan 9: Tattach returns fid. You can clone it or use it. It is NOT open for I/O, you must Topen it.
                // But for directories, some servers allow Tread without open? No, must open.
                // Let's Topen rootFid.
                sendTopen(rootFid);
            } else if (type === 107) { // Rerror
                 // extract error string: size[4] type[1] tag[2] ename[s]
                 const enameLen = view.getUint16(7, true);
                 let ename = '';
                 for(let i=0; i<enameLen; i++) {
                     ename += String.fromCharCode(view.getUint8(9+i));
                 }
                 log(`Error received: ${ename}`);
            } else if (type === 113) { // Ropen
                log('Root Opened (Ropen)');
                sendTread(rootFid, 0, 8192);
            } else if (type === 117) { // Rread
                log('Read Data (Rread)');
                // Decode Dir entries... complex, but we can verify length > 0
                log(`Bytes Read: ${size - 4 - 1 - 2 - 4}`); 
                // Rread: size[4] type[1] tag[2] count[4] data[count]
            }
        };

        const sendTversion = () => {
             // Size: 4+1+2+4+2+6 = 19
             const buf = new ArrayBuffer(19);
             const v = new DataView(buf);
             v.setUint32(0, 19, true);
             v.setUint8(4, 100); // Tversion
             v.setUint16(5, 65535, true); // NOTAG
             v.setUint32(7, 8192, true);
             v.setUint16(11, 6, true);
             const s = "9P2000";
             for(let i=0; i<6; i++) v.setUint8(13+i, s.charCodeAt(i));
             ws.send(buf);
             log('Sent Tversion');
        };

        const sendTattach = () => {
            // Tattach: type[1] tag[2] fid[4] afid[4] uname[s] aname[s]
            // Fid=1, Afid=-1 (NOFID), Uname="web", Aname="/"
            const uname = "web";
            const aname = "/";
            const size = 4 + 1 + 2 + 4 + 4 + (2+uname.length) + (2+aname.length);
            
            const buf = new ArrayBuffer(size);
            const v = new DataView(buf);
            let off = 0;
            v.setUint32(off, size, true); off+=4;
            v.setUint8(off, 104); off+=1; // Tattach
            v.setUint16(off, 1, true); off+=2; // Tag=1
            v.setUint32(off, rootFid, true); off+=4; // Fid=1
            v.setUint32(off, 0xFFFFFFFF, true); off+=4; // Afid=NOFID
            
            v.setUint16(off, uname.length, true); off+=2;
            for(let i=0; i<uname.length; i++) v.setUint8(off+i, uname.charCodeAt(i)); off+=uname.length;
            
            v.setUint16(off, aname.length, true); off+=2;
            for(let i=0; i<aname.length; i++) v.setUint8(off+i, aname.charCodeAt(i)); off+=aname.length;
            
            ws.send(buf);
            log('Sent Tattach');
        }
        
        const sendTopen = (fid) => {
            // Topen: type[1] tag[2] fid[4] mode[1]
            const size = 4 + 1 + 2 + 4 + 1;
            const buf = new ArrayBuffer(size);
            const v = new DataView(buf);
            let off = 0;
            v.setUint32(off, size, true); off+=4;
            v.setUint8(off, 112); off+=1; // Topen
            v.setUint16(off, 2, true); off+=2; // Tag=2
            v.setUint32(off, fid, true); off+=4;
            v.setUint8(off, 0); off+=1; // OREAD
            ws.send(buf);
            log("Sent Topen");
        }

        const sendTread = (fid, offset, count) => {
             // Tread: type[1] tag[2] fid[4] offset[8] count[4]
             const size = 4 + 1 + 2 + 4 + 8 + 4;
             const buf = new ArrayBuffer(size);
             const v = new DataView(buf);
             let off = 0;
             v.setUint32(off, size, true); off+=4;
             v.setUint8(off, 116); off+=1; // Tread
             v.setUint16(off, 3, true); off+=2; // Tag=3
             v.setUint32(off, fid, true); off+=4;
             v.setBigUint64(off, BigInt(offset), true); off+=8;
             v.setUint32(off, count, true); off+=4;
             ws.send(buf);
             log("Sent Tread");
        }

        ws.onerror = (e) => log('Error: ' + e);
        ws.onclose = () => log('Disconnected');

        // --- WebAuthn Functions ---
        
        const base64ToBytes = (b64) => {
            // Convert base64url to base64 if needed
            const standardB64 = b64.replace(/-/g, '+').replace(/_/g, '/');
            const bin = atob(standardB64);
            const bytes = new Uint8Array(bin.length);
            for(let i=0; i<bin.length; i++) bytes[i] = bin.charCodeAt(i);
            return bytes;
        };

        const bytesToBase64 = (bytes) => {
            let bin = '';
            for(let i=0; i<bytes.length; i++) bin += String.fromCharCode(bytes[i]);
            return btoa(bin);
        };

        async function registerPasskey() {
            const username = document.getElementById('username').value || 'alice';
            log(`=== Starting Passkey Registration for user: ${username} ===`);
            
            // 1. Open /dev/factotum/rpc
            const rpcFid = 100;
            await walk9P(rootFid, rpcFid, ['dev', 'factotum', 'rpc']);
            await open9P(rpcFid, 2); // ORDWR for read+write
            
            // 2. Write start command
            const startCmd = `start proto=webauthn role=register user=${username}`;
            await write9P(rpcFid, startCmd);
            
            // 3. Read challenge
            const challengeResp = await read9P(rpcFid);
            log(`Challenge Response: ${challengeResp}`);
            
            // Parse metadata: "challenge user=... role=... challenge=<b64> userid=<b64> rpid=<rpid>"
            const challengeMatch = challengeResp.match(/challenge=([^ ]+)/);
            const useridMatch = challengeResp.match(/userid=([^ ]+)/);
            const rpidMatch = challengeResp.match(/rpid=([^ ]+)/);
            
            if (!challengeMatch) throw new Error("Challenge not found in response");
            const challenge = base64ToBytes(challengeMatch[1]);
            const userID = useridMatch ? base64ToBytes(useridMatch[1]) : new TextEncoder().encode(username);
            
            // SECURITY FIX: For local dev, the rpID MUST match the window hostname exactly.
            // If Factotum says "localhost" but we are on "127.0.0.1", we must use the origin hostname.
            const rpIDFromSess = rpidMatch ? rpidMatch[1] : window.location.hostname;
            const rpID = (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') 
                ? window.location.hostname 
                : rpIDFromSess;
            
            log(`Using RP ID: ${rpID}`);
            if (window.location.hostname !== rpID && !window.location.hostname.endsWith(rpID)) {
                log(`Warning: Possible RP ID mismatch! (Hostname: ${window.location.hostname}, RP ID: ${rpID})`);
            }
            
            // 4. Call WebAuthn API
            log('Calling navigator.credentials.create()...');
            const credential = await navigator.credentials.create({
                publicKey: {
                    challenge: challenge,
                    rp: { name: "Ten OS", id: rpID },
                    user: {
                        id: userID,
                        name: username,
                        displayName: username
                    },
                    pubKeyCredParams: [
                        { alg: -7, type: "public-key" },   // ES256
                        { alg: -257, type: "public-key" } // RS256
                    ],
                    timeout: 60000,
                    attestation: "none"
                }
            });
            
            log('Passkey created! Sending to Factotum...');
            
            // 5. Send clientDataJSON and attestationObject separately (text protocol)
            const clientDataB64 = bytesToBase64(new Uint8Array(credential.response.clientDataJSON));
            const attestationB64 = bytesToBase64(new Uint8Array(credential.response.attestationObject));
            await write9P(rpcFid, `write ${clientDataB64} ${attestationB64}`);
            
            // 6. Read ticket
            const ticketResp = await read9P(rpcFid);
            log(`✓ Registration Complete: ${ticketResp}`);
        }

        async function loginPasskey() {
            const username = document.getElementById('username').value || 'alice';
            log(`=== Starting Passkey Login for user: ${username} ===`);
            
            // 1. Open /dev/factotum/rpc
            const rpcFid = 101;
            await walk9P(rootFid, rpcFid, ['dev', 'factotum', 'rpc']);
            await open9P(rpcFid, 2); // ORDWR for read+write
            
            // 2. Write start command
            const startCmd = `start proto=webauthn role=auth user=${username}`;
            await write9P(rpcFid, startCmd);
            
            // 3. Read challenge
            const challengeResp = await read9P(rpcFid);
            log(`Challenge Response: ${challengeResp}`);
            
            // Parse metadata
            const challengeMatch = challengeResp.match(/challenge=([^ ]+)/);
            const rpidMatch = challengeResp.match(/rpid=([^ ]+)/);
            
            if (!challengeMatch) throw new Error("Challenge not found in response");
            const challenge = base64ToBytes(challengeMatch[1]);
            
            // SECURITY FIX: Match RP ID to current hostname for local dev
            const rpIDFromSess = rpidMatch ? rpidMatch[1] : window.location.hostname;
            const rpID = (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') 
                ? window.location.hostname 
                : rpIDFromSess;
            
            log(`Using RP ID: ${rpID}`);
            
            // 4. Call WebAuthn API
            log('Calling navigator.credentials.get()...');
            const assertion = await navigator.credentials.get({
                publicKey: {
                    challenge: challenge,
                    timeout: 60000,
                    rpId: rpID
                }
            });
            
            log('Assertion received! Sending to Factotum...');
            
            // 5. Send clientDataJSON, authenticatorData, signature, and userHandle
            const clientDataB64 = bytesToBase64(new Uint8Array(assertion.response.clientDataJSON));
            const authenticatorDataB64 = bytesToBase64(new Uint8Array(assertion.response.authenticatorData));
            const signatureB64 = bytesToBase64(new Uint8Array(assertion.response.signature));
            const userHandleB64 = assertion.response.userHandle ? bytesToBase64(new Uint8Array(assertion.response.userHandle)) : "none";
            
            await write9P(rpcFid, `write ${clientDataB64} ${authenticatorDataB64} ${signatureB64} ${userHandleB64}`);
            
            // 6. Read ticket
            const ticketResp = await read9P(rpcFid);
            log(`✓ Login Complete: ${ticketResp}`);
        }

        // --- 9P Message Helpers with Promise Support ---
        
        let nextTag = 10;
        const pendingRequests = new Map();

        // Update message handler to resolve promises
        const originalOnMessage = ws.onmessage;
        ws.onmessage = (event) => {
            const view = new DataView(event.data);
            const size = view.getUint32(0, true);
            const type = view.getUint8(4);
            const tag = view.getUint16(5, true);
            
            // Check if this is a promise-based request
            if (pendingRequests.has(tag)) {
                const { resolve, reject } = pendingRequests.get(tag);
                pendingRequests.delete(tag);
                
                if (type === 107) { // Rerror
                    const enameLen = view.getUint16(7, true);
                    let ename = '';
                    for(let i=0; i<enameLen; i++) {
                        ename += String.fromCharCode(view.getUint8(9+i));
                    }
                    reject(new Error(ename));
                } else {
                    resolve({ view, type, tag, size });
                }
            } else {
                // Call original handler for initial connection flow
                originalOnMessage(event);
            }
        };

        // Helper: Walk to path
        function walk9P(fromFid, toFid, path) {
            return new Promise((resolve, reject) => {
                const tag = nextTag++;
                const wname = path; // array of strings
                
                // Calculate size: 4+1+2+4+4+2+(2+len)*n
                let size = 4+1+2+4+4+2;
                for(const name of wname) size += 2 + name.length;
                
                const buf = new ArrayBuffer(size);
                const v = new DataView(buf);
                let off = 0;
                
                v.setUint32(off, size, true); off+=4;
                v.setUint8(off, 110); off+=1; // Twalk
                v.setUint16(off, tag, true); off+=2;
                v.setUint32(off, fromFid, true); off+=4;
                v.setUint32(off, toFid, true); off+=4;
                v.setUint16(off, wname.length, true); off+=2;
                
                for(const name of wname) {
                    v.setUint16(off, name.length, true); off+=2;
                    for(let i=0; i<name.length; i++) {
                        v.setUint8(off++, name.charCodeAt(i));
                    }
                }
                
                pendingRequests.set(tag, { resolve, reject });
                ws.send(buf);
                log(`Sent Twalk(${fromFid}->${toFid}, ${path.join('/')})`);
            });
        }

        // Helper: Open fid
        function open9P(fid, mode = 0) {
            return new Promise((resolve, reject) => {
                const tag = nextTag++;
                const size = 4+1+2+4+1;
                const buf = new ArrayBuffer(size);
                const v = new DataView(buf);
                let off = 0;
                
                v.setUint32(off, size, true); off+=4;
                v.setUint8(off, 112); off+=1; // Topen
                v.setUint16(off, tag, true); off+=2;
                v.setUint32(off, fid, true); off+=4;
                v.setUint8(off, mode); off+=1; // OREAD=0, OWRITE=1, ORDWR=2
                
                pendingRequests.set(tag, { resolve, reject });
                ws.send(buf);
                log(`Sent Topen(${fid}, mode=${mode})`);
            });
        }

        // Helper: Write to fid
        function write9P(fid, data) {
            return new Promise((resolve, reject) => {
                const tag = nextTag++;
                const bytes = new TextEncoder().encode(data);
                const size = 4+1+2+4+8+4+bytes.length;
                const buf = new ArrayBuffer(size);
                const v = new DataView(buf);
                let off = 0;
                
                v.setUint32(off, size, true); off+=4;
                v.setUint8(off, 118); off+=1; // Twrite
                v.setUint16(off, tag, true); off+=2;
                v.setUint32(off, fid, true); off+=4;
                v.setBigUint64(off, 0n, true); off+=8; // offset=0
                v.setUint32(off, bytes.length, true); off+=4;
                
                for(let i=0; i<bytes.length; i++) {
                    v.setUint8(off++, bytes[i]);
                }
                
                pendingRequests.set(tag, { resolve, reject });
                ws.send(buf);
                log(`Sent Twrite(${fid}, ${bytes.length} bytes)`);
            });
        }

        // Helper: Read from fid
        function read9P(fid, offset = 0, count = 8192) {
            return new Promise((resolve, reject) => {
                const tag = nextTag++;
                const size = 4+1+2+4+8+4;
                const buf = new ArrayBuffer(size);
                const v = new DataView(buf);
                let off = 0;
                
                v.setUint32(off, size, true); off+=4;
                v.setUint8(off, 116); off+=1; // Tread
                v.setUint16(off, tag, true); off+=2;
                v.setUint32(off, fid, true); off+=4;
                v.setBigUint64(off, BigInt(offset), true); off+=8;
                v.setUint32(off, count, true); off+=4;
                
                pendingRequests.set(tag, {
                    resolve: (resp) => {
                        // Parse Rread: size[4] type[1] tag[2] count[4] data[count]
                        const dataCount = resp.view.getUint32(7, true);
                        let text = '';
                        for(let i=0; i<dataCount; i++) {
                            text += String.fromCharCode(resp.view.getUint8(11+i));
                        }
                        resolve(text);
                    },
                    reject
                });
                ws.send(buf);
                log(`Sent Tread(${fid}, offset=${offset}, count=${count})`);
            });
        }

    </script>
</body>
</html>
